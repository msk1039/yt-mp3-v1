# YouTube to MP3 Converter - Development Context (Enhanced Architecture)

You are helping build a YouTube to MP3 converter web application with microservices architecture optimized for VPS deployment.

## Tech Stack
- **Frontend**: Next.js with shadcn/ui components
- **Backend**: Python with FastAPI
- **Queue System**: Redis with Celery for background processing
- **External APIs**: YouTube Data API for URL validation
- **Tools**: yt-dlp for video downloading, ffmpeg for audio conversion
- **Containerization**: Docker with multi-container setup

## Project Structure
```
youtube-mp3-converter/
├── frontend/                    # Next.js application (Container 1)
│   ├── components/ui/          # shadcn/ui components
│   ├── app/                    # Next.js app router
│   │   ├── api/               # API route handlers
│   │   ├── page.tsx           # Home page
│   │   ├── layout.tsx         # Root layout
│   │   └── loading.tsx        # Loading UI
│   ├── lib/                   # Utility functions
│   ├── styles/                # CSS/Tailwind styles
│   └── Dockerfile             # Frontend container
├── backend/                    # Python FastAPI services (Container 2)
│   ├── api_gateway/           # Main API server
│   │   ├── main.py           # FastAPI app entry point
│   │   ├── routers/          # API route handlers
│   │   └── middleware/       # Auth, CORS, validation
│   ├── download_service/      # yt-dlp operations microservice
│   │   ├── worker.py         # Celery worker for downloads
│   │   └── utils.py          # Download utilities
│   ├── conversion_service/    # ffmpeg operations microservice
│   │   ├── worker.py         # Celery worker for conversion
│   │   └── converter.py      # Audio conversion logic
│   ├── file_service/          # File storage and serving
│   │   ├── storage.py        # File management
│   │   └── cleanup.py        # Temp file cleanup
│   ├── shared/                # Shared utilities
│   │   ├── redis_client.py   # Redis connection
│   │   ├── youtube_api.py    # YouTube Data API integration
│   │   └── models.py         # Pydantic models
│   ├── requirements.txt       # Python dependencies
│   └── Dockerfile            # Backend container
├── docker-compose.yml         # Multi-container orchestration
└── nginx.conf                # Reverse proxy configuration
```

## Architecture Overview

### Microservices (All in Container 2)
1. **API Gateway** (FastAPI): Main entry point, request routing, authentication
2. **Download Service**: Handles yt-dlp operations via Celery workers
3. **Conversion Service**: Handles ffmpeg operations via Celery workers  
4. **File Service**: Manages file storage, serving, and cleanup

### Queue-Based Processing
- **Redis**: Message broker and task queue
- **Celery**: Distributed task queue for Python
- **Background Workers**: Handle downloads/conversions asynchronously

## Backend Implementation (Python FastAPI)

### Core Dependencies
```python
# requirements.txt
fastapi==0.104.1
celery==5.3.4
redis==5.0.1
yt-dlp==2023.11.16
google-api-python-client==2.108.0
pydantic==2.5.0
uvicorn==0.24.0
python-multipart==0.0.6
aiofiles==23.2.0
```

### API Gateway (main.py)
```python
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from routers import download, status, batch
from shared.youtube_api import validate_youtube_url
```

### Key Components

#### 1. Job Queue System
- Use Celery with Redis backend
- Separate queues for download and conversion tasks
- Task chaining: download → convert → cleanup

#### 2. API Endpoints
- `POST /api/download` - Single URL submission
- `POST /api/batch` - Multiple URLs/playlist submission
- `GET /api/status/{task_id}` - Check processing status
- `GET /api/download/{task_id}` - Download converted file(s)
- `GET /api/progress/{task_id}` - Real-time progress updates

#### 3. YouTube Data API Integration
```python
# Validate URLs before processing
def validate_youtube_url(url: str) -> bool:
    # Use YouTube Data API to verify video exists
    # Extract video ID and check accessibility
```

#### 4. Batch Processing Features
- Multiple URL submissions in single request
- Playlist URL support (extract all video URLs)
- ZIP file creation for multiple downloads
- Progress tracking for batch operations

### Microservice Workers

#### Download Service Worker
```python
@celery_app.task(bind=True)
def download_audio(self, video_url: str, task_id: str):
    # Use yt-dlp to extract audio
    # Update progress via Redis
    # Chain to conversion task
```

#### Conversion Service Worker  
```python
@celery_app.task(bind=True)
def convert_to_mp3(self, webm_file: str, task_id: str):
    # Use ffmpeg for conversion
    # Update progress via Redis
    # Chain to cleanup task
```

#### File Service
```python
class FileManager:
    def store_file(self, file_path: str) -> str
    def serve_file(self, file_id: str) -> FileResponse
    def cleanup_temp_files(self, task_id: str)
    def create_zip_archive(self, files: List[str]) -> str
```

## Frontend Implementation (Next.js)

### Enhanced UI Components
- **Single URL Input**: Basic conversion interface
- **Batch Upload**: Multiple URL input with playlist support
- **Progress Tracking**: Real-time progress bars
- **Download Manager**: List of completed/pending downloads
- **Error Handling**: Detailed error messages and retry options

### State Management
```typescript
interface ConversionState {
  tasks: Task[]
  currentTask: string | null
  batchMode: boolean
  progress: Record<string, number>
}
```

### API Integration with Polling
```typescript
// Poll for status updates
const pollTaskStatus = async (taskId: string) => {
  // Check conversion progress
  // Update UI accordingly
}
```

## Containerization Strategy

### Container 1: Frontend (Next.js)
```dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build
EXPOSE 3000
CMD ["npm", "start"]
```

### Container 2: Backend Services
```dockerfile
FROM python:3.11-slim
# Install system dependencies
RUN apt-get update && apt-get install -y \
    ffmpeg \
    && rm -rf /var/lib/apt/lists/*
    
# Install yt-dlp
RUN pip install yt-dlp

WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .

# Start multiple services
CMD ["sh", "-c", "celery -A shared.celery_app worker --detach && uvicorn api_gateway.main:app --host 0.0.0.0 --port 8000"]
```

### Docker Compose Setup
```yaml
version: '3.8'
services:
  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
  
  backend:
    build: ./backend
    ports:
      - "8000:8000"
    environment:
      - REDIS_URL=redis://redis:6379
      - YOUTUBE_API_KEY=${YOUTUBE_API_KEY}
    depends_on:
      - redis
  
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
  
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
```

## Prerequisites & Local Development Setup

### System Requirements
1. **Python 3.11+** installed
2. **Node.js 18+** and npm installed
3. **Redis Server** running locally (`redis-server`)
4. **FFmpeg** installed and accessible via PATH
5. **yt-dlp** installed (`pip install yt-dlp`)

### Environment Setup
```bash
# Backend setup
cd backend/
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
pip install -r requirements.txt

# Frontend setup  
cd frontend/
npm install
npx shadcn-ui@latest init
```

### Required API Keys
- **YouTube Data API Key**: Get from Google Cloud Console
- Create `.env` files in both frontend and backend directories

### Local Development Ports
- Frontend (Next.js): `http://localhost:3000`
- Backend (FastAPI): `http://localhost:8000`
- Redis: `localhost:6379`

## Step-by-Step Development Workflow

### Step 1: Basic Frontend Setup
**Goal**: Create a simple page with URL input, loading state, and download functionality using shadcn/ui

**Tasks for this step:**
1. The nextjs app is already initialised by the developer with shadcn ui and typescript 
2. All the shadcn components all already installed
2. Create a single `homepage.tsx` component in frontend/components/homepage.tsx with:
   - Input field for YouTube URL
   - Submit button with loading spinner
   - Download link area
   - Error message display
3. Set up basic state management (useState hooks)
4. Create placeholder API call structure

**Expected Components**: Input, Button, Card, Alert from shadcn/ui

### Step 2: Basic FastAPI Backend
**Goal**: Create minimal FastAPI server with single endpoint

**Tasks for this step:**
1. Set up FastAPI project structure
2. Create main.py with basic CORS setup
3. Add single POST endpoint `/api/download` that:
   - Accepts YouTube URL
   - Returns task ID immediately
   - Does NOT process video yet (just mock response)
4. Test endpoint with frontend connection

### Step 3: Frontend-Backend Integration
**Goal**: Connect frontend form to backend API

**Tasks for this step:**
1. Implement actual API calls in frontend
2. Handle loading states properly
3. Display backend responses
4. Add basic error handling
5. Test full request/response cycle

### Step 4: YouTube URL Validation
**Goal**: Add YouTube Data API validation

**Tasks for this step:**
1. Set up YouTube Data API credentials
2. Create validation function in backend
3. Add URL format checking
4. Return proper error messages for invalid URLs
5. Update frontend to handle validation errors

### Step 5: Redis + Basic Queue Setup
**Goal**: Set up Redis connection and basic task queuing

**Tasks for this step:**
1. Install and configure Redis locally
2. Add Redis client to FastAPI
3. Create basic task storage (without Celery first)
4. Add task status endpoint `/api/status/{task_id}`
5. Implement polling in frontend

### Step 6: yt-dlp Integration
**Goal**: Add actual video download functionality

**Tasks for this step:**
1. Create download function using yt-dlp
2. Download audio in webm format to temp directory
3. Store file path in Redis with task ID
4. Update task status during download
5. Test with real YouTube URLs

### Step 7: FFmpeg Audio Conversion
**Goal**: Convert webm to mp3 format

**Tasks for this step:**
1. Add ffmpeg conversion function
2. Convert webm files to mp3
3. Update task status during conversion
4. Clean up temporary webm files
5. Store final mp3 file path

### Step 8: File Serving & Download
**Goal**: Serve converted mp3 files to users

**Tasks for this step:**
1. Add file serving endpoint `/api/file/{task_id}`
2. Implement file download in frontend
3. Add proper file headers and metadata
4. Test complete download flow
5. Add file cleanup after serving

### Step 9: Celery Integration
**Goal**: Replace basic queuing with proper Celery workers

**Tasks for this step:**
1. Set up Celery with Redis backend
2. Convert download/conversion functions to Celery tasks
3. Add proper task chaining
4. Implement progress tracking
5. Test concurrent processing

### Step 10: Enhanced UI & Error Handling
**Goal**: Improve user experience and error handling

**Tasks for this step:**
1. Add progress bars and better loading states
2. Implement comprehensive error handling
3. Add retry functionality
4. Improve UI styling with shadcn/ui
5. Add download history/status display

### Step 11: Batch Processing Foundation
**Goal**: Add support for multiple URLs

**Tasks for this step:**
1. Modify frontend to accept multiple URLs
2. Add batch processing endpoint
3. Handle multiple tasks in UI
4. Add playlist URL parsing
5. Test with multiple videos

### Step 12: ZIP File Generation
**Goal**: Create ZIP files for batch downloads

**Tasks for this step:**
1. Add ZIP file creation functionality
2. Combine multiple mp3 files into archive
3. Serve ZIP files through download endpoint
4. Update UI for batch download links
5. Test ZIP file creation and download

### Final Step: Deployment Preparation
**Goal**: Prepare for containerized deployment

**Tasks for this step:**
1. Create Dockerfile for backend
2. Create Dockerfile for frontend
3. Set up docker-compose.yml
4. Create nginx configuration
5. Test full containerized setup locally

## Development Guidelines for Each Step

### Code Incremental Approach
- Complete each step fully before moving to next
- Test thoroughly at each step
- Keep code simple and readable
- Add comprehensive error handling
- Use proper TypeScript types

### Testing Strategy
- Test each API endpoint with curl/Postman
- Verify frontend state changes
- Check file operations manually
- Validate error scenarios
- Test with various YouTube URLs

### File Structure Reminders
- Keep components small and focused
- Separate API logic from UI components
- Use proper error boundaries
- Implement loading states consistently
- Follow FastAPI and Next.js best practices

**Start with Step 1** and ask for specific implementation of the basic frontend page.tsx component with shadcn/ui before proceeding to backend setup.

## Security & Performance

### Input Validation
- YouTube Data API validation before processing
- URL sanitization and format checking
- Rate limiting per IP address
- File size and duration limits

### Performance Optimizations
- Concurrent processing with Celery workers
- Redis caching for repeated requests
- Efficient file cleanup scheduling
- Progress streaming for better UX

## Environment Variables
```bash
YOUTUBE_API_KEY=your_youtube_api_key
REDIS_URL=redis://localhost:6379
CELERY_BROKER_URL=redis://localhost:6379
CELERY_RESULT_BACKEND=redis://localhost:6379
MAX_CONCURRENT_DOWNLOADS=3
CLEANUP_INTERVAL=3600
```

When implementing, prioritize:
1. Queue-based asynchronous processing
2. Proper microservice communication
3. Comprehensive error handling and retry logic
4. Efficient file management and cleanup
5. Real-time progress updates
6. Container orchestration and VPS deployment

Start with the FastAPI gateway and Redis setup, then build each microservice incrementally while testing the queue system thoroughly.